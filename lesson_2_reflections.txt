-----------------------------------------------------------------------

What happens when you initialize a repository? Why do you need to do
it?

When you initialize a repository using the git init command, a .git
folder is created in the current directory, where changes and commits
to tracked files will be logged and preserved. A history of all the
tracked files that are committed will be created.

You need to initialize a repository, in order to create versions of
files you want to track, for when working on projects. It's a good way
to assure oneself that any mistakes/bugs can be (more) easily fixed,
and otherwise irreperable harm to the project is reversible. This
provides the confidence required to innovate on a project and
experiment with new ideas, with a peace of mind.

-----------------------------------------------------------------------

How is the staging area different from the working directory and the
repository? What value do you think it offers?

The staging area is the intermediate waypoint between the working
directory and the repository, for prospective new files that are likely
to be committed. Files are first added from the working directory to
the staging area. Once a file in the staging area is committed, that
file is then added to the repository, for its initial commit.

The staging area makes it easier to manage which files to commit,
rather than simply committing the files and adding them to the
repository right away. The value in this is that it makes the process
of committing files and adding them to the repository more
user-friendly, and it is less likely that unwanted files will be added
to the repository.

-----------------------------------------------------------------------

How can you use the staging area to make sure you have one commit per
logical change?

You can add a file to the staging area using the command git add; then
if changes are made to the file afterwards, you can use the command
git diff to compare that file in the working directory with the
corresponding file in the staging area, to determine if any
significant logical changes were made, before committing the file. You
can also use the command git diff --staged for this same purpose, when
comparing the file in the staging area to the most recent commit of
that file.

-----------------------------------------------------------------------

What are some situations when branches would be helpful in keeping your
history organized? How would branches help?

If you want to test new features or create editions of a project,
branches make it a lot easier to separate them and organize them, so
that you can work with each individually. Branches allow you to make
changes to the master version of the project and spinoff versions,
without any interference between them.

-----------------------------------------------------------------------





-----------------------------------------------------------------------





-----------------------------------------------------------------------





-----------------------------------------------------------------------